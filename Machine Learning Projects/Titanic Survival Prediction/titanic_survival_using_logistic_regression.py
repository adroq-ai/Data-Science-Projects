# -*- coding: utf-8 -*-
"""Titanic Survival using Logistic Regression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hEi5jfODwEJYzq_SeqX9Dc5hWg9A2nhS

#**Titanic - Machine Learning from Disaster**

##**Description**

The competition is simple: use machine learning to create a model that predicts which passengers survived the Titanic shipwreck.

##**The Challenge**

The sinking of the Titanic is one of the most infamous shipwrecks in history.

On April 15, 1912, during her maiden voyage, the widely considered “unsinkable” RMS Titanic sank after colliding with an iceberg. Unfortunately, there weren’t enough lifeboats for everyone onboard, resulting in the death of 1502 out of 2224 passengers and crew.

While there was some element of luck involved in surviving, it seems some groups of people were more likely to survive than others.

In this challenge, we ask you to build a predictive model that answers the question: “what sorts of people were more likely to survive?” using passenger data (ie name, age, gender, socio-economic class, etc).


##**Overview**

The data has been split into two groups:

**training set (train.csv)**

**test set (test.csv)**

The training set should be used to build your machine learning models. For the training set, we provide the outcome (also known as the “ground truth”) for each passenger. Your model will be based on “features” like passengers’ gender and class. You can also use feature engineering to create new features.

The test set should be used to see how well your model performs on unseen data. For the test set, we do not provide the ground truth for each passenger. It is your job to predict these outcomes. For each passenger in the test set, use the model you trained to predict whether or not they survived the sinking of the Titanic.

We also include **gender_submission.csv**, a set of predictions that assume all and only female passengers survive, as an example of what a submission file should look like.

**Data Dictionary**

**Variable**  |	**Definition** |   	**Key**

survival	| Survival	 |   0 = No, 1 = Yes

pclass	  | Ticket class|	 1 = 1st, 2 = 2nd, 3 = 3rd

sex       |	   Sex

Age       |   Age in years

sibsp     |	# of siblings / spouses aboard the Titanic

parch	    |  # of parents / children aboard the Titanic

ticket    |	Ticket number

fare      |	Passenger fare

cabin     |	Cabin number

embarked  |	Port of Embarkation	C = Cherbourg, Q = Queenstown, S = Southampton

**Variable Notes**

**pclass**: A proxy for socio-economic status (SES)

1st = Upper

2nd = Middle

3rd = Lower

**age**: Age is fractional if less than 1. If the age is estimated, is it in the form of xx.5

**sibsp**: The dataset defines family relations in this way...

Sibling = brother, sister, stepbrother, stepsister

Spouse = husband, wife (mistresses and fiancés were ignored)

**parch**: The dataset defines family relations in this way...

Parent = mother, father

Child = daughter, son, stepdaughter, stepson

Some children travelled only with a nanny, therefore parch=0 for them.

# **Installing require Tools**
"""

pip install gradio

"""#**Import the Libraries**"""

## import some basic libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import gradio as gr

"""#**Data Collection and Preprocessing**"""

# Loading the dataset into a pandas DataFrame
titanic_data = pd.read_csv('train.csv')  # Use this to identify issues

# Display the first few rows
print("First 5 rows of the dataset:")
titanic_data.head()

# Display the last few rows
print("Last 5 rows of the dataset:")
titanic_data.tail()

# Checking the shape of the dataset
titanic_data.shape    # Outputs the number of rows and columns in the dataset.

# Statistical description of the dataset
print("\nStatistical Description of the Dataset:")
titanic_data.describe()

# Check for missing values
missing_values = titanic_data.isnull().sum()
print("\nMissing values in each column:")
print(missing_values)

# Generating some Information about the dataset
titanic_data.info()

"""**Handling the Missing values**"""

# Drop the "Cabin" column from the DataFrame
titanic_data = titanic_data.drop(columns='Cabin', axis=1)

# Finding the mean value of "Age" column
print(titanic_data['Age'].mean())

# Finding the mean value of "Age" column
print(titanic_data['Age'].median())

# Replacing the missing values in "Age" column with mean values
titanic_data['Age'].fillna(titanic_data['Age'].mean(), inplace=True)

# Finding the mode value of "Embarked" column
print(titanic_data['Embarked'].mode())

print(titanic_data['Embarked'].mode()[0])

# Replacing the missing values in "Embarked" column with mode value
titanic_data['Embarked'].fillna(titanic_data['Embarked'].mode()[0], inplace=True)

# Check for missing values
missing_values = titanic_data.isnull().sum()
print("\nMissing values in each column:")
print(missing_values)

"""# **Data Analysis and Data Visualization**"""

# Statistical description of the dataset
print("\nStatistical Description of the Dataset:")
titanic_data.describe()

# Finding the number of people that Survived and Not Survived
titanic_data['Survived'].value_counts()

"""**0 ---> Not Survived**

**1 ---> Survived**
"""

sns.set

# Checking the distribution of Survived column
print("\nDistribution of Survived Data:")
titanic_data['Survived'].value_counts()

# Distribution Vertical Count Plot graph of Survived Column
plt.figure(figsize=(6,6))
sns.countplot(x='Survived', data=titanic_data)
plt.title("Survived Distribution")
plt.show()

# Distribution Horizontal Count Plot graph of Survived Column
plt.figure(figsize=(6,6))
sns.countplot(y='Survived', data=titanic_data)
plt.title("Survived Distribution")
plt.show()

# Checking the distribution of Sex column
print("\nDistribution of Sex Data:")
titanic_data['Sex'].value_counts()

# Distribution Vertical Count Plot graph of Sex Column
plt.figure(figsize=(6,6))
sns.countplot(x='Sex', data=titanic_data)
plt.title("Sex Distribution")
plt.show()

# Distribution Horizontal Count Plot graph of Sex Column
plt.figure(figsize=(6,6))
sns.countplot(y='Sex', data=titanic_data)
plt.title("Sex Distribution")
plt.show()

# Distribution Count Plot graph of Survivors based on Gender wise
plt.figure(figsize=(6,6))
sns.countplot(x='Sex', hue='Survived', data=titanic_data)
plt.title("Sex with Survived Distribution Comparison")
plt.show()

# Checking the distribution of Pclass column
print("\nDistribution of Pclass Data:")
titanic_data['Pclass'].value_counts()

# Distribution Vertical Count Plot graph of Pclass Column
plt.figure(figsize=(6,6))
sns.countplot(x='Pclass', data=titanic_data)
plt.title("Pclass Distribution")
plt.show()

# Distribution Vertical Count Plot graph of Embarked Column
plt.figure(figsize=(6,6))
sns.countplot(x='Pclass', hue='Survived', data=titanic_data)
plt.title("Pclass with Survived Distribution Comparison")
plt.show()

# Finding the number of SibSp people
titanic_data['SibSp'].value_counts()

# Distribution Vertical Count Plot graph of SibSp Column
plt.figure(figsize=(6,6))
sns.countplot(x='SibSp', data=titanic_data)
plt.title("SibSp Distribution")
plt.show()

# Distribution Vertical Count Plot graph of SibSp Column
plt.figure(figsize=(6,6))
sns.countplot(x='SibSp', hue='Survived', data=titanic_data)
plt.title("SibSp with Survived Distribution Comparison")
plt.show()

# Checking the distribution of Parch column
print("\nDistribution of Parch Data:")
titanic_data['Parch'].value_counts()

# Distribution Vertical Count Plot graph of Parch Column
plt.figure(figsize=(6,6))
sns.countplot(x='Parch', data=titanic_data)
plt.title("Parch Distribution")
plt.show()

# Distribution Vertical Count Plot graph of Parch Column
plt.figure(figsize=(6,6))
sns.countplot(x='Parch', hue='Survived', data=titanic_data)
plt.title("Parch with Survived Distribution Comparison")
plt.show()

# Checking the distribution of Embarked column
print("\nDistribution of Embarked Data:")
titanic_data['Embarked'].value_counts()

# Distribution Vertical Count Plot graph of Embarked Column
plt.figure(figsize=(6,6))
sns.countplot(x='Embarked', data=titanic_data)
plt.title("Embarked Distribution")
plt.show()

# Distribution Vertical Count Plot graph of Embarked Column
plt.figure(figsize=(6,6))
sns.countplot(x='Embarked', hue='Survived', data=titanic_data)
plt.title("Embarked with Survived Distribution Comparison")
plt.show()

# Distribution graph of age value
sns.set()
plt.figure(figsize=(6,6))
sns.distplot(titanic_data["Age"])
plt.title("Age Distribution")
plt.show()

# Distribution graph of Fare value
sns.set()
plt.figure(figsize=(6,6))
sns.distplot(titanic_data["Fare"])
plt.title("Fare Distribution")
plt.show()

# Select only numeric columns
numeric_data = titanic_data.select_dtypes(include=['number'])

# Compute the correlation matrix
corr = numeric_data.corr()

# Print the correlation matrix
print(corr)

# Create the heatmap with enhancements
plt.figure(figsize=(8, 8))
sns.heatmap(
    corr,
    annot=True,
    fmt=".2f",
    cmap="coolwarm",
    cbar_kws={"shrink": 0.8},
    linewidths=0.5,
    square=True,
    annot_kws={"size": 8, "weight": "bold"},
)
plt.title("Enhanced Correlation Heatmap of Titanic Survival", fontsize=14, fontweight="bold", pad=15)
plt.xticks(fontsize=10, rotation=45, ha="right", weight="bold")
plt.yticks(fontsize=10, weight="bold")
plt.tight_layout()

"""#**Data Preprocessing**

**Encoding the Categorical column**
"""

# Finding the number of the Sex people
titanic_data['Sex'].value_counts()

# Finding the number of Embarked people
titanic_data['Embarked'].value_counts()

# Encoding the categorical column
titanic_data.replace({'Sex':{'male':0,'female':1}, 'Embarked':{'S':0,'C':1,'Q':2}}, inplace=True)

# Display the first few rows
print("First 5 rows of the dataset:")
titanic_data.head()

# @title PassengerId

from matplotlib import pyplot as plt
titanic_data['PassengerId'].plot(kind='hist', bins=20, title='PassengerId')
plt.gca().spines[['top', 'right',]].set_visible(False)

"""**Splitting the dataset into Features & Target**"""

# Splitting the dataset into Dependents & Independent
X = titanic_data.drop(columns = ['PassengerId','Name','Ticket','Survived'],axis=1)
y = titanic_data['Survived']

print("Features (X):")
print(X.head())
print("\nTarget (y):")
print(y.head())

"""# **Splitting the dataset into Training and Test sets**"""

# Splitting the dataset into Training and Test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, stratify=y,  random_state=3)
print("\nDataset split completed:")
print(f"Total samples: {X.shape[0]}, Training samples: {X_train.shape[0]}, Test samples: {X_test.shape[0]}")

# checking the number of Test and Train dataset
print(X.shape, X_train.shape, X_test.shape)

"""# **Model Training**"""

# Initialize the model
logReg_model = LogisticRegression()

# Training the LogisticRegression model with train data
logReg_model.fit(X_train, y_train)

"""#**Model Evaluation**"""

# Calculate accuracy on the training data
X_train_pred = logReg_model.predict(X_train)
train_data_accuracy = accuracy_score(X_train_pred, y_train)
print('Accuracy on training data : ', train_data_accuracy)

# Generate and display the confusion matrix on the training data
# The confusion matrix shows the counts of True Positives, True Negatives, False Positives, and False Negatives
conf_matrix = confusion_matrix(y_train, X_train_pred)
print("\nConfusion Matrix:")
print(conf_matrix)

# Generate and display the classification report
# The classification report includes precision, recall, F1-score, and support for each class
class_report = classification_report(y_train, X_train_pred, target_names=["Not Survived (0)", "Survived (1)"])
print("\nClassification Report:")
print(class_report)

# accuracy on the test data
X_test_pred = logReg_model.predict(X_test)
test_data_accuracy = accuracy_score(X_test_pred, y_test)
print('Accuracy on test data : ', test_data_accuracy)

# Generate and display the confusion matrix on the test data
# The confusion matrix shows the counts of True Positives, True Negatives, False Positives, and False Negatives
conf_matrix = confusion_matrix(y_test, X_test_pred)
print("\nConfusion Matrix:")
print(conf_matrix)

# Generate and display the classification report
# The classification report includes precision, recall, F1-score, and support for each class
class_report = classification_report(y_test, X_test_pred, target_names=["Not Survived (0)", "Survived (1)"])
print("\nClassification Report:")
print(class_report)

"""# **Making a Predictive System**"""

# Sample input data (new instance to classify)
input_data = [3, 0, 22, 1, 0, 7.25, 0]

# Converting input data to a NumPy array
input_data_as_numpy_array = np.asarray(input_data)

# Reshaping the input array for prediction (to match model's expected input shape)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

# Making a prediction
prediction = logReg_model.predict(input_data_reshaped)
print(prediction)

# Outputting the result
if prediction[0] == 0:
    print("The Person Survived in Titanic Sinking Accident  (i.e. Survived)")
else:
    print("The Person does not Survived in Titanic Sinking  (i.e. Not Survived)")

# Sample input data (new instance to classify)
input_data = [1, 1, 38, 1, 0, 71.2833, 1]

# Converting input data to a NumPy array
input_data_as_numpy_array = np.asarray(input_data)

# Reshaping the input array for prediction (to match model's expected input shape)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

# Making a prediction
prediction = logReg_model.predict(input_data_reshaped)
print(prediction)

# Outputting the result
if prediction[0] == 0:
    print("The Person Survived in Titanic Sinking Accident  (i.e. Survived)")
else:
    print("The Person does not Survived in Titanic Sinking  (i.e. Not Survived)")

def predict_titanic_survival(input_data):
    """
    Predicts titanic survival based on input data using the trained using Logistic Regression model.

    Parameters:
        input_data (list): A list of values corresponding to the features in the order:
                           [Pclass, Sex, Age, SibSp ,Parch, Fare, Cabin]

    Returns:
        str: Prediction result (Survived or Not Survived).
    """
    # Convert input_data to a NumPy array
    input_array = np.array(input_data).reshape(1, -1)

    # Ensure the model and scaler (if used) are applied to the input
    prediction = logReg_model.predict(input_array)

    # Interpret and return the result
    if prediction[0] == 0:
        return "The Person Survived in Titanic Sinking Accident (i.e. Survived)"
    else:
        return "The Person does not Survived in Titanic Sinking  (i.e. Not Survived)"

# Example: Predict for a Titanic Survival or Not Survival
# Sample data: [Pclass, Sex, Age, SibSp ,Parch, Fare, Embarked]
sample_data = [3, 0, 0, 0, 330877, 8.4583, 2]


# Call the function to predict
result = predict_titanic_survival(sample_data)
print("Prediction Result:", result)

def gradio_predict(Pclass, Sex, Age, SibSp ,Parch, Fare, Embarked):
    # Convert inputs to a list
    input_data = [
        int(Pclass), int(Sex), float(Age), int(SibSp),
        int(Parch), float(Fare), int(Embarked)
        ]

    # Call the prediction function (you need to define predict_titanic_survival)
    prediction = predict_titanic_survival(input_data)  # Ensure predict_titanic_survival is defined
    return prediction

# Set up the Gradio interface
interface = gr.Interface(
    fn=gradio_predict,
    inputs=[
        gr.Dropdown(["1", "2", "3"],label="Pclass"),
        gr.Dropdown(["0", "1"], label="Sex"),
        gr.Number(label="Age"),
        gr.Dropdown(["0", "1", "2", "3", "4", "5", "8"],label="SibSp"),
        gr.Dropdown(["0", "1", "2", "3", "4", "5", "6"],label="Parch"),
        gr.Number(label="Fare"),
        gr.Dropdown(["0", "1", "2"],label="Embarked"),

    ],
    outputs=gr.Textbox(label="Prediction Result"),
    title="Titanic Survival Prediction",
    description="Enter the required details to predict if a Passenger Survived or Not."
)

# Launch the interface
interface.launch()