# -*- coding: utf-8 -*-
"""Wine  Quality Prediction using  RandomForest Classifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L7n2pjDsRLyzYVCKDRUip1EPce9Unu06

# **Installing require Tools**
"""

pip install gradio

"""#**Import the Libraries**"""

## import some basic libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import gradio as gr

"""#**Data Collecction**"""

# Loading the dataset into a pandas DataFrame
wine_data = pd.read_csv('winequality-red.csv')  # Use this to identify issues

# Display the first few rows
print("First 5 rows of the dataset:")
wine_data.head()

# Checking the shape of the dataset
wine_data.shape    # Outputs the number of rows and columns in the dataset.

# Check for missing values
missing_values = wine_data.isnull().sum()
print("\nMissing values in each column:")
print(missing_values)

"""#**Data Analysis and Visualization**"""

# Statistical description of the dataset
print("\nStatistical Description of the Dataset:")
wine_data.describe()

# Number of values for each quality
wine_data['quality'].value_counts()

sns.catplot(x='quality', data=wine_data, kind='count')

# Volatile Acidity vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='volatile acidity')

# Citric Acid vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='citric acid')

# Fixed Acidity vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='fixed acidity')

# Residuaal Sugar vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='residual sugar')

# Chlorides vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='chlorides')

# Free sulfur dioxide vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='free sulfur dioxide')

# Total sulfur dioxide vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='total sulfur dioxide')

# Density vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='density')

# pH vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='pH')

# Sulphates vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='sulphates')

# Alcohol vs Quality
plot = plt.figure(figsize=(5,5))
sns.barplot(data=wine_data, x='quality', y='alcohol')

"""**Correlation**"""

corr = wine_data.corr()
print(corr)

# Create the heatmap with enhancements
plt.figure(figsize=(10, 10))
sns.heatmap(
    corr,
    annot=True,
    fmt=".2f",
    cmap="coolwarm",
    cbar_kws={"shrink": 0.8},
    linewidths=0.5,
    square=True,
    annot_kws={"size": 8, "weight": "bold"},
)
plt.title("Enhanced Correlation Heatmap", fontsize=14, fontweight="bold", pad=15)
plt.xticks(fontsize=10, rotation=45, ha="right", weight="bold")
plt.yticks(fontsize=10, weight="bold")
plt.tight_layout()

"""#**Data Preprocessing**"""

# Splitting features and target
X = wine_data.drop(columns=['quality'],axis=1)
print(X)

"""**Label Binarization**"""

y = wine_data['quality'].apply(lambda y_value: 1 if y_value>=7 else 0)
print(y)

"""# **Splitting the Dataset into Training and Test Sets**"""

# Splitting the dataset into Training and Test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=1)
print("\nDataset split completed:")
print(f"Total samples: {X.shape[0]}, Training samples: {X_train.shape[0]}, Test samples: {X_test.shape[0]}")

"""# **Model Training --> Random Forest Classifier**"""

# Initialize the model
model_rfc = RandomForestClassifier()

# Fit the model on the training data
model_rfc.fit(X_train, y_train)

"""# **Model Evaluation**"""

# Calculate accuracy on the training data
X_train_pred = model_rfc.predict(X_train)
train_data_accuracy = accuracy_score(X_train_pred, y_train)
print('Accuracy on training data : ', train_data_accuracy)

# Generate and display the confusion matrix on the training data
# The confusion matrix shows the counts of True Positives, True Negatives, False Positives, and False Negatives
conf_matrix = confusion_matrix(y_train, X_train_pred)
print("\nConfusion Matrix:")
print(conf_matrix)

# Generate and display the classification report
# The classification report includes precision, recall, F1-score, and support for each class
class_report = classification_report(y_train, X_train_pred, target_names=["Not_Good (0)", "Good (1)"])
print("\nClassification Report:")
print(class_report)

# accuracy on the test data
X_test_pred = model_rfc.predict(X_test)
test_data_accuracy = accuracy_score(X_test_pred, y_test)
print('Accuracy on test data : ', test_data_accuracy)

# Generate and display the confusion matrix on the test data
# The confusion matrix shows the counts of True Positives, True Negatives, False Positives, and False Negatives
conf_matrix = confusion_matrix(y_test, X_test_pred)
print("\nConfusion Matrix:")
print(conf_matrix)

# Generate and display the classification report
# The classification report includes precision, recall, F1-score, and support for each class
class_report = classification_report(y_test, X_test_pred, target_names=["Not_Good (0)", "Good (1)"])
print("\nClassification Report:")
print(class_report)

"""# **Making a Predictive System**"""

# Sample input data (new instance to classify)
input_data = [7.9,0.6,0.06,1.6,0.069,15.0,59.0,0.9964,3.3,0.46,9.4]

# Converting input data to a NumPy array
input_data_as_numpy_array = np.asarray(input_data)

# Reshaping the input array for prediction (to match model's expected input shape)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

# Making a prediction
prediction = model_rfc.predict(input_data_reshaped)
print(prediction)

# Outputting the result
if (prediction[0]==1):
  print('Good Quality Wine')
else:
  print('Bad Quality Wine')

# Sample input data (new instance to classify)
input_data = [7.9,0.35,0.46,3.6,0.078,15.0,37.0,0.9973,3.35,0.86,12.8]

# Converting input data to a NumPy array
input_data_as_numpy_array = np.asarray(input_data)

# Reshaping the input array for prediction (to match model's expected input shape)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

# Making a prediction
prediction = model_rfc.predict(input_data_reshaped)
print(prediction)

# Outputting the result
if (prediction[0]==1):
  print('Good Quality Wine')
else:
  print('Bad Quality Wine')

def predict_wine_quality(input_data):
    """
    Predicts wine quality based on input data using the trained RandomForestclassifier model.

    Parameters:
        input_data (list): A list of values corresponding to the features in the order:
                           [fixed acidity, volatile acidity, citric acid, residual sugar,
                           chlorides, free sulfur dioxide, total sulfur dioxide, density, pH,
                           sulphates, alcohol]

    Returns:
        str: Prediction result (Good Quality Wine or Bad Quality Wine).
    """
    # Convert input_data to a NumPy array
    input_array = np.array(input_data).reshape(1, -1)

    # Ensure the model and scaler (if used) are applied to the input
    prediction = model_rfc.predict(input_array)

    # Interpret and return the result
    if prediction[0] == 1:
        return "Good Quality Wine"
    else:
        return "Bad Quality Wine"

# Example: Predict for a new customer
# Sample data: [fixed acidity, volatile acidity, citric acid, residual sugar,
                # chlorides, free sulfur dioxide, total sulfur dioxide, density, pH,
                # sulphates, alcohol]
sample_data = [12.6,0.31,0.72,2.2,0.07,6.0,29.0,0.9987,2.88,0.82,9.8]

# Call the function to predict
result = predict_wine_quality(sample_data)
print("Prediction Result:", result)

# Define the Gradio interface
import gradio as gr

def gradio_predict(fixed_acidity, volatile_acidity, citric_acid, residual_sugar, chlorides,
                   free_sulfur_dioxide, total_sulfur_dioxide, density, pH,
                   sulphates, alcohol):
    # Convert inputs to a list
    input_data = [
        float(fixed_acidity), float(volatile_acidity), float(citric_acid), float(residual_sugar),
        float(chlorides), float(free_sulfur_dioxide), float(total_sulfur_dioxide), float(density),
        float(pH), float(sulphates), float(alcohol)
    ]

    # Call the prediction function (you need to define predict_wine_quality)
    prediction = predict_wine_quality(input_data)  # Ensure predict_wine_quality is defined
    return prediction

# Set up the Gradio interface
interface = gr.Interface(
    fn=gradio_predict,
    inputs=[
        gr.Number(label="Fixed Acidity"),
        gr.Number(label="Volatile Acidity"),
        gr.Number(label="Citric Acid"),
        gr.Number(label="Residual Sugar"),
        gr.Number(label="Chlorides"),
        gr.Number(label="Free Sulfur Dioxide"),
        gr.Number(label="Total Sulfur Dioxide"),
        gr.Number(label="Density"),
        gr.Number(label="pH"),
        gr.Number(label="Sulphates"),
        gr.Number(label="Alcohol"),
    ],
    outputs=gr.Textbox(label="Prediction Result"),
    title="Wine Quality Prediction",
    description="Enter the required details to predict if a wine will be Good."
)

# Launch the interface
interface.launch()