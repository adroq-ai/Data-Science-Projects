# -*- coding: utf-8 -*-
"""Movie Recommendation System Cosine_Similarity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N_ZWCHNKaWV-8q2krFG3jitreyJdMlRb
"""

!pip install scikit-learn

pip install gradio

"""#**Import the Libraries**"""

import pandas as pd
import difflib
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

"""#**Data Collection and Preprocessing**"""

# Loading the dataset into a pandas DataFrame
movies_dataset = pd.read_csv('movies.csv', on_bad_lines='skip', engine='python') # Use this to identify issues

# Display the first few rows
print("First 5 rows of the dataset:")
movies_dataset.head()

# Display the last few rows
print("Last 5 rows of the dataset:")
movies_dataset.tail()

# Checking the shape of the dataset
movies_dataset.shape    # Outputs the number of rows and columns in the dataset.

# Check for missing values
missing_values = movies_dataset.isnull().sum()
print("\nMissing values in each column:")
print(missing_values)

# Selected the relevant features for recommendation
selected_features = ["genres", "keywords", "tagline", "cast", "director", "original_language", "popularity", "vote_average", "title", "spoken_languages", "runtime","production_countries"]
print(selected_features)

# Replacing the the null values with null string
for feature in selected_features:
    movies_dataset[feature] = movies_dataset[feature].fillna('')

# Combining all the selected features
combined_features = movies_dataset["genres"] + " " + movies_dataset["keywords"] + " " + movies_dataset["tagline"] + " " + movies_dataset["cast"] + " " + movies_dataset["director"] + " " + movies_dataset["original_language"] + " " + str(movies_dataset["popularity"]) + " " + str(movies_dataset["vote_average"]) + " " + movies_dataset["title"] + " " + movies_dataset["spoken_languages"] + " " + str(movies_dataset["runtime"]) + " " + movies_dataset["production_countries"]

print(combined_features)

# Convert the combined_features(text data)  into feature vectors
vectorizer = TfidfVectorizer()

feature_vectors = vectorizer.fit_transform(combined_features)
print(feature_vectors)

"""#**Cosine Similarity**"""

# Getting the similarity scores using cosine similarity
similarity = cosine_similarity(feature_vectors)
print(similarity)

print(similarity.shape)

"""#**Getting the movie name from the User**"""

# Getting the movie name from the user
movie_name = input("Enter your favourite movie name: ")

# Creating a list with all the movies names given in the datast
list_of_all_titles = movies_dataset["title"].tolist()
print(list_of_all_titles)

# Finding the close match for the movie name by the user
find_close_match = difflib.get_close_matches(movie_name, list_of_all_titles)
print(find_close_match)

close_match = find_close_match[0]
print(close_match)

# Finding the index of the movie with title
index_of_the_movie = movies_dataset[movies_dataset.title == close_match]["index"].values[0]
print(index_of_the_movie)

# Getting a list of similar movies
similarity_score = list(enumerate(similarity[index_of_the_movie]))
print(similarity_score)

len(similarity_score)

# Sorting the movies based on their similarity score
sorted_similar_movies = sorted(similarity_score, key = lambda x:x[1], reverse = True)   # Arranging in desccending value
print(sorted_similar_movies)

# Print the name of similar movies based on the index
print("Movies Recommended for you based on the title given to me : \n")

i = 1

for movie in sorted_similar_movies:
  index = movie[0]
  title_from_index = movies_dataset[movies_dataset.index==index]["title"].values[0]
  if (i < 31):
    print(i, ".", title_from_index)
    i += 1

"""#**Movie Recommendation System**"""

# Getting the movie name from the user
movie_name = input("Enter your favourite movie name: ")

# Creating a list with all the movies names given in the datast
list_of_all_titles = movies_dataset["title"].tolist()

# Finding the close match for the movie name by the user
find_close_match = difflib.get_close_matches(movie_name, list_of_all_titles)
close_match = find_close_match[0]

# Finding the index of the movie with title
index_of_the_movie = movies_dataset[movies_dataset.title == close_match]["index"].values[0]

# Getting a list of similar movies
similarity_score = list(enumerate(similarity[index_of_the_movie]))

# Sorting the movies based on their similarity score
sorted_similar_movies = sorted(similarity_score, key = lambda x:x[1], reverse = True)   # Arranging in desccending value

# Print the name of similar movies based on the index
print("Movies Recommended for you based on the title given to me : \n")

i = 1

for movie in sorted_similar_movies:
  index = movie[0]
  title_from_index = movies_dataset[movies_dataset.index==index]["title"].values[0]
  if (i < 31):
    print(i, ".", title_from_index)
    i += 1

# Getting the movie name from the user
movie_name = input("Enter your favourite movie name: ")

# Creating a list with all the movies names given in the datast
list_of_all_titles = movies_dataset["title"].tolist()

# Finding the close match for the movie name by the user
find_close_match = difflib.get_close_matches(movie_name, list_of_all_titles)
close_match = find_close_match[0]

# Finding the index of the movie with title
index_of_the_movie = movies_dataset[movies_dataset.title == close_match]["index"].values[0]

# Getting a list of similar movies
similarity_score = list(enumerate(similarity[index_of_the_movie]))

# Sorting the movies based on their similarity score
sorted_similar_movies = sorted(similarity_score, key = lambda x:x[1], reverse = True)   # Arranging in desccending value

# Print the name of similar movies based on the index
print("Movies Recommended for you based on the title given to me : \n")

i = 1

for movie in sorted_similar_movies:
  index = movie[0]
  title_from_index = movies_dataset[movies_dataset.index==index]["title"].values[0]
  if (i < 31):
    print(i, ".", title_from_index)
    i += 1

# Getting the movie name from the user
movie_name = input("Enter your favourite movie name: ")

# Creating a list with all the movies names given in the datast
list_of_all_titles = movies_dataset["title"].tolist()

# Finding the close match for the movie name by the user
find_close_match = difflib.get_close_matches(movie_name, list_of_all_titles)
close_match = find_close_match[0]

# Finding the index of the movie with title
index_of_the_movie = movies_dataset[movies_dataset.title == close_match]["index"].values[0]

# Getting a list of similar movies
similarity_score = list(enumerate(similarity[index_of_the_movie]))

# Sorting the movies based on their similarity score
sorted_similar_movies = sorted(similarity_score, key = lambda x:x[1], reverse = True)   # Arranging in desccending value

# Print the name of similar movies based on the index
print("Movies Recommended for you based on the title given to me : \n")

i = 1

for movie in sorted_similar_movies:
  index = movie[0]
  title_from_index = movies_dataset[movies_dataset.index==index]["title"].values[0]
  if (i < 31):
    print(i, ".", title_from_index)
    i += 1

"""#**Summary of the code With gradio as the Recommendation System**"""

import pandas as pd
import difflib
import gradio as gr
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# Load the dataset
movies_dataset = pd.read_csv('movies.csv')

# Fill missing values with an empty string
movies_dataset['overview'] = movies_dataset['overview'].fillna("")

# TF-IDF Vectorizer to convert text into numerical form
vectorizer = TfidfVectorizer(stop_words='english')
tfidf_matrix = vectorizer.fit_transform(movies_dataset['overview'])

# Compute similarity score
similarity = cosine_similarity(tfidf_matrix)

def recommend_movies(movie_name):
    # Convert to lowercase for case-insensitive search
    movie_name = movie_name.lower()

    # Create a list with all movie titles
    list_of_all_titles = movies_dataset["title"].str.lower().tolist()

    # Find the closest match
    find_close_match = difflib.get_close_matches(movie_name, list_of_all_titles, n=1)

    if not find_close_match:
        return "No similar movie found. Try another title."

    close_match = find_close_match[0]

    # Get the index of the closest movie
    index_of_the_movie = movies_dataset[movies_dataset.title.str.lower() == close_match].index.values[0]

    # Compute similarity scores
    similarity_score = list(enumerate(similarity[index_of_the_movie]))

    # Sort movies based on similarity score
    sorted_similar_movies = sorted(similarity_score, key=lambda x: x[1], reverse=True)

    # Get the top 10 similar movies
    recommended_movies = [movies_dataset.iloc[movie[0]]["title"] for movie in sorted_similar_movies[1:11]]

    return recommended_movies

# Define Gradio Interface
interface = gr.Interface(
    fn=recommend_movies,
    inputs=gr.Textbox(label="Enter a Movie Title", placeholder="e.g. Inception"),
    outputs=gr.Textbox(label="Recommended Movies"),
    title="Movie Recommendation System",
    description="Enter the name of a movie, and I'll recommend similar movies."
)

# Launch the Gradio UI
interface.launch()